grammar gram;

COMMENT : '//'~[\n]* -> skip;
SEMI : ';';
WHILE : 'while';
LP : [(];
RP : [)];
IF : 'if';
ELSE : 'else';
RETURN : 'return';
LBR : [{];
RBR : [}];
FPNUM : ([\\d]+[\\.][\\d]*|[\\.][\\d]+)([Ee][-+]?[\\d]+)?|[-]?[\\d]+[Ee][-+]?[\\d]+;
NUM : '-'? [0-9]+;
OR : 'or';
AND : 'and';
NOT : 'not';
RELOP : '>='|'<='|'>'|'<'|'!='|'==';
EQ : '=';
PLUS : [+];
MULOP : [*/%];
MINUS : '-';
CMA : ',';
TYPE : ('int'|'string'|'double');
STRINGCONSTANT : ["]([\\"]|[\\n]|[\\\\]|~["])*["];
PRINT : 'print';
INPUT : 'input';
OPEN : 'open';
READ : 'read';
WRITE : 'write';
CLOSE : 'close';
ID : [A-Za-z_]+;
WHITESPACE : ( ' ' | '\t' | '\n' | '\r' )+ -> skip   ;

start : program EOF;
program : varDeclList braceblock;
stmts : stmt stmts | ;
stmt : cond | loop | returnStmt SEMI | assign SEMI | funcCall SEMI;
loop : WHILE LP expr RP braceblock;
cond : IF LP expr RP braceblock | IF LP expr RP braceblock ELSE braceblock;
braceblock : LBR stmts RBR;
returnStmt : RETURN expr;
expr : orexp;
orexp : orexp OR andexp | andexp ;
andexp : andexp AND notexp | notexp;
notexp :  NOT notexp | rel;
rel : sum RELOP sum | sum;
sum :  sum PLUS term | sum MINUS term | term;
term :  term MULOP neg | neg;
neg :  MINUS neg | factor;
factor :  NUM | LP expr RP | FPNUM | ID | STRINGCONSTANT | funcCall;
varDeclList : varDecl SEMI varDeclList | ;
varDecl : TYPE ID;
assign : ID EQ expr;
funcCall : builtinFuncCall | userFuncCall;
userFuncCall : ID LP optionalExprlist RP;
optionalExprlist :  | exprlist;
exprlist : exprlist CMA expr | expr;
builtinFuncCall : PRINT LP expr RP | INPUT LP RP | OPEN LP expr RP | READ LP expr RP | WRITE LP exprlist RP | CLOSE LP expr RP;
